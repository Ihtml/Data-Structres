## 散列表的定义

查找的本质是**已知对象找位置**。一般有两种方式：

- 有序安排对象:全序(二分查找)、半序(查找树)
- 直接“算出”对象位置: **散列**



**散列表**（**Hash table**，也叫**哈希表**），是根据键Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做**散列表**。时间复杂度几乎是常亮：O(1), 即查找时间与问题规模无关；



散列查找法的两项基本工作:

- 计算位置:构造**散列函数**确定关键词存储位置;
- 解决冲突:应用**某种策略**解决多个关键词位置相同的问题；



散列的**基本思想**是：

1. 以关键字**key**为自变量，通过一个确定的函数 h(**散列函数**)，计算出对应的函数值**h(key)**，作为数据对象的存储地址。
2. 可能不同的关键字会映射到同一个散列地址上，即h(keyi) = h(keyj)(当keyi ≠keyj)，称为“**冲突**(Collision)”。 ----需要某种冲突解决策略

**装填因子(Loading Factor):**设散列表空间大小为m，填入表 中元素个数是n，则称**α= n / m**为散列表的装填因子

如果没有溢出：T查询 = T插入 = T删除 = O(1)



## 散列函数构造方法

好的散列函数要考虑下列两个因素：

1. 计算简单，以便提高转换速度;
2. 关键词对应的地址空间分布均匀，以尽量减少冲突。



数字关键字的散列函数构造：

1. 直接定址法

   取关键词的某个线性函数值为散列地址，即h(key) = a*key + b (a、b为常数)

2. 除留余数法(常用)

   散列函数为:h(key) = key mod p， 一般 p取素数，为表的大小；

3. 数字分析法

   分析数字关键字在各位上的变化情况，取比较随机的位作为散列地址；

4. 折叠法

   把关键字分割成位数相同的几个部分，然后叠加；

5. 平方取中法

   把key取平方，取中间几位作为地址；



字符关键词的散列函数构造

1. 一个简单的散列函数——ASCII码加和法

   对字符型关键词key定义散列函数如下：h(key) = (Σkey[i]) mod TableSize

   问题：冲突严重，比如：a3、 b2、c1;

2. 简单的改进——前3个字符移位法

   h(key)=(key[0]272 + key[1]27 + key[2])mod TableSize

   问题：仍然有冲突：string、 street、 strong、structure等等，空间浪费：3000/263 ≈ 30%

3. 好的散列函数——**移位法**

   把字符串看做32进制的数字；

   例如：h(“abcde”)=‘a’*32^4+’b’*32^3+’c’*32^2+’d’*32+’e’，

   优点：涉及关键词所有n个字符，并且分布得很好；

   构造函数

   ```c
   Index Hash(const char *Key, int TableSize){
   	unsigned int h = 0; // 散列初始值设为0
     while(*Key != '\0')
       h = (h << 5) + *Key++; // 左移5位相等于乘32
     return h%TableSize;
   }
   ```

   

## 散列查找处理冲突的方法

#### 常用处理冲突的思路：

- 换个位置：**开放地址法**，一旦产生了冲突（该地址已有其它元素），就按某种规则去寻找另一个空地址；
- 同一个位置的冲突对象组织在一起：**链地址法**

散列表查找性能分析：查找表中关键词的平均查找比较次数--成功平均查找长度为**ASLs,**；不在散列表中的关键词的平均查找次数(不成功)--不成功平均查找长度为**ASLu**；一个数取余数后，判定不在该表中，需要比较的次数的平均；

#### 开放定址法：

若发生了第i次冲突，试探的下一个地址将增加di, 基本公式为：

hi(key) = (h(key)+di) mod TableSize ( 1 <= i < tableSize)

dj决定了不同的解决冲突方案：线性探测(di=i)、平方探测(二次探测 di = $\pm$i^2)、双散列(di = i*h2(key))。

在开放地址散列表中，删除操作要很小心。 通常只能“**懒惰删除**”，即需要增加一个“ 删除标记(Deleted)”，而并不是真正删除它。 以便查找时不会“断链”。其空间可以在 下次插入时重用。

##### 线性探测法：

以增量序列 1，2，......，(TableSize -1)，循环试探下一个存储地址。

问题：会产生“聚集”现象，产生冲突的地方，冲突会不断聚集越来越多；



##### 平方探测法：

以增量序列12，-12，22，-22，......，q2，-q2且q ≤ |TableSize/2| 循环试探下一个存储地址。

平方探测法可以避免产生聚集问题，但可能有空间平方探测找不到；

有定理显示：如果散列表长度TableSize是某个**4k+3**(k是正整数)形式的**素数**时，平方检测法就可以探查到整个散列表空间；



##### 双散列探测法：

再设计一个散列函数，使得发生冲突时。di为i*h2(key),h2(key)是另一个散列函数，探测序列成：h2(key), 2h2(key), 3h2(key); 对任意的key，h2(key)不等于0；，为了保证所有的散列存储单元都应该被探测到，应该选择以下形式：h2(key)=p-(key mod p), p< TableSize, p、TableSize都是素数。



##### 再散列

当散列表元素太多(即装填因子 α太大)时，查找效率会下降;实用最大装填因子一般取 0.5 <= α<= 0.85。当装填因子过大时，解决的方法是加倍扩大散列表，这个过程叫 做“**再散列**(Rehashing)”





