## 一、线性表
### 1. 逆转顺序表中的所有元素 
算法思想:第一个元素和最后一个元素对调，第二个元素和倒数第二个元素对调，......，依此类推。
```c++
void Reverse(int A[], int n) {
    int i, t;
    for (i = 0; i < n / 2; i++) {
        t = A[i];
        A[i] = A[n - i - 1];
        A[n - i - 1] = t;
    }
}
```

### 2. 删除线性链表中数据域为item的所有结点
算法思想:先从链表的第 2 个结点开始，从前往后依次判断链表中的所有结点是否满足条件，若某个 结点的数据域为 item，则删除该结点。最后再回过头来判断链表中的第 1 个结点是否满足条件，若满足则将其删除。
```c++
void PurgeItem(LinkList& list) {
    LinkList p, q = list;
    p = list->next;
    while (p != NULL) {
        if (p->data == item) {
            q->next = p->next;
            free(p);
            p = q->next;
        } else {
            q = p;
            p = p->next;
        }
    }
    if (list->data == item) {
        q = list;
        list = list->next;
        free(q);
    }
}
```
### 3. 逆转线性链表
```c++
void Reverse(LinkList& list) {
    LinkList p, q, r;
    p = list;
    q = NULL;
    while (p != NULL) {
        r = q;
        q = p;
        p = p->next;
        q->next = r; // 切断和原链表的联系
    }
    list = q;
}
```

### 4. 复制线性链表(递归)
```c++
LinkList Copy(LinkList lista) {
    LinkList listb;
    if (lista == NULL)
        return NULL;
    else {
        listb = (LinkList)malloc(sizeof(LNode));
        listb->data = lista->data;
        listb->next = Copy(lista->next);
        return listb;
    }
}
```

### 5. 将两个按值有序排列的非空线性链表合并为一个按值有序的线性链表
```c++
LinkList MergeList(LinkList lista, LinkList listb) {
    LinkList listc, p = lista, q = listb, r;
    // listc 指向 lista 和 listb 所指结点中较小者
    if (lista->data <= listb->data) {
        listc = lista;
        r = lista;
        p = lista->next;
    } else {
        listc = listb;
        r = listb;
        q = listb->next;
    }
    while (p != NULL && q != NULL) {
        if (p->data <= q->data) {
            r->next = p;
            r = p; // r = r->next
            p = p->next;
        } else {
            r->next = q;
            r = q; // r = r->next
            q = q->next;
        }
    }
    // 将剩余结点(即未参加比较的且已按升序排列的结点)链接到整个链表后面
    r->next = (p != NULL) ? p : q;
    return listc;
}
```

## 二、树
### 1. 二叉树的先序遍历(非递归算法)
算法思想:若 p 所指结点不为空，则访问该结点，然后将该结点的地址入栈，然后再将 p 指向其左孩子结点;若 p 所指向的结点为空，则从堆栈中退出栈顶元素(某个结点的地址)，将 p 指向其右孩子结点。重复上述过程，直到 p = NULL 且堆栈为空，遍历结束。
```c++
#define MAX_STACK 50
void PreOrderTraverse(BTree T) {
    BTree STACK[MAX_STACK], p = T;
    int top = -1;
    while (p != NULL || top != -1) {
        while (p != NULL) {
            VISIT(p);
            STACK[++top] = p;
            p = p->lchild;
        }
        p = STACK[top--];
        p = p->rchild;
    }
}
```