### 算法的基本概念
**算法**是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。算法具有以下5个z重要特性：
1. 有穷性 一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。
2. 确定性 算法中每条指令必须有确切的含义，对于相同的输入只能有相同的输出。
3. 可行性 算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。
4. 输入 一个算法有零个或多个输入，这些输入取自于某个特定的对象集合。
5. 输出 一个算法有一个或多个输出，这些输出是与输入有特定关系的量。

好的算法应该达到的目标：
1. 正确性  算法应能够正确地解决求解问题
2. 可读性  算法应具有良好的可读性，以帮助人们理解
3. 健壮性  输入非法数据时，算法能适当地做出反应或处理，而不会产生莫名其妙的输出结果。
4. 效率与低存储需求 效率是指算法执行时间，存储需求是指算法执行过程中所需要的最大存储空间，这两者都与问题的规模有关。

### 算法效率的度量
1. 时间复杂度
一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为T(n);它是该算法问题规模n的函数。时间复杂度主要分析T(n)的数量级。
算法中基本运算（最深层循环内的语句）的频度与T(n)同数量级，因此通常采用算法中基本运算的频度f(n)来分析算法时间复杂度。 T(n) = O(f(n))
算法的时间复杂度不仅依赖于问题的规模n，也取决于待输入数据的性质（如输入数据元素的初始状态）
```c++
// 在数组A中查找给定值k的算法
int i = n-1; // 1
while(i>0 && (A[i] !=k))  // 2
i--;  // 3
return i;  // 4
```
语句3的频度不仅与问题规模n有关，且与实例A中各元素的取值及k的取值有关
若A中没有与k相等的元素，则语句3的频度f(n)=n;
如A的最后一个元素等于k, 则语句3的频度f(n)是常数0；
**最坏时间复杂度**：在最坏情况下，算法的时间复杂度
**平均时间复杂度**：所有可能输入的实例在等概率出现的情况下，算法的期望运行时间。
**最好时间复杂度**：最好情况下，算法的时间复杂度。
一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。

2. 空间复杂度
算法的空间复杂度S(n)定义为改算法说耗费的存储空间，它是问题规模n的函数。 S(n) = O(g(n))
一个程序在执行时除需要存储空间来存放本身所用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间。
若输入数据所占空间只取决于问题本身，和算法无关，则只需分析除输入和程序之外的额外空间。
算法**原地工作**是指算法所需的辅助空间为常量，即O(1)

3. 分析程序时间复杂度的方法和步骤
- 循环主体中的变量参与循环条件的判断
找出主体语句中与T(n)成正比的循环变量，将之带入条件中进行计算。
```c++
// 例1
int i = 1;
while(i <= n)
  i=i*2;

// 例2
int y=5;
while( (y+1)*(y+1) < n)
  y=y+1;
```
例1中 i乘以2的次数正是主题语句的执行次数t, 2^t<=n;
取对数后得t<=log2n, 则T(n)=O(log2n)
例2中  y加1的次数恰好与T(n)成正比，T(n)=O(n^(1/2))

- 循环主体中的变量与循环条件无关
可采用数学归纳法或直接累积循环次数，多层循环时从内到外分析，忽略单步语句、条件判断语句，只关注主体语句的执行次数。
递归程序一般使用公式进行递推。
非递归程序比较简单，可以直接累积次数。
```c++
// O(n)=log2^n
void fun(int n){
    int i=1;
    while(i<n)
        i=i*2;
}
// O(n)=n开3次方
void fun(int n){
    int i = 0;
    while(i*i*i<=n)
        i++;
}
// 冒泡排序，当所有相邻元素都为逆序时，最后一行元素每次都会执行
for(int i=n-1; i>0; i--)
    for(int j=1; j<i; j++)
        if(A[j]>A[j+1])
            swap(A[j], A[j+1])
            // 最坏情况复杂度 O(n^2)

int m=0,i,j;
for(i=1;i<=n;i++)
    for(j=1;j<=2*i;j++)
        m++;  // 执行n*(n+1)次

// T(n)=O(log2n)
int x = 2;
while(x< n/2)
x=2*x;

// 求整数n的阶乘  时间复杂度 O(n)
int fact(int n){
    if(n<=1) return 1;
    return n*fact(n-1);
}

// 时间复杂度 O(n*log2n)
int count = 0;
for(int k=1; k<=n; k*=2)
    for(int j=1; j<n; j++)
        count++;

// 时间复杂度 O(n^(1/2))
int func(int n){
    int i = 0, sum = 0;
    while(sum<n) sum += ++i;
    return i;
}
```