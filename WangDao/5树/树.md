### 树的基本性质
- 树种一个结点的孩子格式称为该结点的**度**。树中结点的最大度数称为树的度。
- 树中的结点数等于所有结点的度数之和加1.
- 度为m的树中第i层上至多有m^(i-1)个结点。
- 高度为h的m叉树，至多有(m^h - 1)/(m-1)个结点
- 具有n个结点的m叉树，最小高度为 [logm(n(m-1) +1)]向上取整

### 二叉树链式存储结构
```c++
typedef struct BiTNode{
    int data;
    struct BiTNode *lchild, *right;
}BiTNode, *BiTree;
```

### 二叉树遍历
```c++
// 先序遍历
void PreOrder(Bitree T){
    if(T != NULL){
        visit(T);
        PreOrder(T->lchild);
        PreOrder(T->rchild);
    }
}
// 中序遍历
void InOrder(Bitree T){
    if(T != NULL){
        InOrder(T->lchild);
        visit(T);
        InOrder(T->rchild);
    }
}
// 后序遍历
void PostOrder(Bitree T){
    if(T != NULL){
        PostOrder(T->lchild);
        PostOrder(T->rchild);
        visit(T);
    }
}
// 非递归中序遍历
void InOrder2(BiTree T){
    InitStack(S); // 初始化栈
    BiTree p=T; //  p是遍历指针
    while(p || !IsEmpty(S)){ // 栈不空或p不空时循环
        if(p){
            Push(S, p);
            p=p->lchild;
        }
        else{
            Pop(S,p); 
            visit(p);
            p=p->rchild;
        }
    }
}
// 非递归先序遍历
void PreOrder2(BiTree T){
    InitStack(S); // 初始化栈
    BiTree p=T; //  p是遍历指针
    while(p || !IsEmpty(S)){ // 栈不空或p不空时循环
        if(p){
            visit(p);
            Push(S, p);
            p=p->lchild;
        }
        else{
            Pop(S,p); 
            p=p->rchild;
        }
    }
}

void PostOrder2(BiTree T){
    InitStack(S); // 初始化栈
    BiTree p=T;
    BiTree r=NULL;
    while(p||!IsEmpty){
        if(p){ 
            push(S,p);
            p=p->lchild;  // 走到最左边
        }else{    // 向右
            GetTop(S,p);
            if(p->rchild&&p-rchild!=r)  // 若右子树存在，且未被访问过
                p=p->rchild;  // 转向右
            else{ 
                pop(S,p);
                visit(p->data);
                r=p;  // 记录最近访问过的结点
                p=NULL;  // 结点访问完后，重置p指针
            }
        }
    }
}
```