### 图的邻接矩阵
```c++
#define MaxVertexNum 100
typedef char VertexType;
typedef int EdgeType;
typedef struct {
    char Vex[MaxVertexNum];
    int Edge[MaxVertexNum][MaxVertexNum];
    int vexnum, arcnum;
}MGraph;
```

### 图的邻接表
```c++
typedef struct ArcNode{ // 边表结点
    int adjvex;  // 该弧指向的顶点的位置
    struct ArcNode *next;  // 指向下一条弧的指针
}ArcNode;
typedef struct VNode{  // 顶点表结点
    char data;  // 
    ArcNode *first;  //
}VNode, AdjList[MaxVertexNum];
typedef struct{
    AdjList vertices; // 邻接表
    int vexnum,arcnum; // 图的顶点数和弧数
} ALGraph;  // 以邻接表存储的图类型

```

### 图的广度优先搜索
```c++
bool visited[MaxVertexNum]; // 访问标记数组

void BFSTraverse(Graph G) {
  for (int i = 0; i < G.vexnum; i++)
    visited[i]=false;  // 访问标记数组初始化
  InitQueue(Q);  // 初始化辅助队列Q
  for (int i = 0; i < G.vexnum; i++){  // 从0号顶点开始遍历
    if(!visted[i])  // 对每个连通分量调用一次BFS
      BFS(G, i); 
  }
}

void BFS(Graph G, int v){
  visit(v);
  visited[v] = true;
  Enqueue(Q, v);  // 顶点v入队列
  while (!isEmpty(Q)) {
    DeQueue(Q, v);
    for (w= FirstNeighbor(G, v); w>=0; w=NextNeighbor(G,v,w)) { // 检测v所有邻接点
      if (!visited[w]) {  // w为v的尚未访问的邻接顶点
        visit[w];
        visited[w]=true;
        Enqueue(Q,w);
      } // if
    } // for
  } // while
}
```

### 单元最短路径问题
```c++
void BFS_MIN_Distance(Graph G, int u){
  // d[i]表示从u到i结点的最短路径
  for (int i = 0; i < G.vexnum; i++)
      d[i] = ∞;
  visited[u] = true;
  d[u]=0;
  EnQueue(Q,u);
  while (!isEmpty(Q)){
    DeQueue(Q,u);
    for ( w=FirstNeighbor(G,u); w>=0; NextNeighbor(G,u,w))  {
      if (!visited[w]) {
        visited[w]=true;
        d[w]=d[u]+1;
        EnQueue(Q,w); 
      }  // if
    }
  }  // while
}
```