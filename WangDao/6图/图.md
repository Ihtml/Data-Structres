### 图的邻接矩阵
```c++
#define MaxVertexNum 100
typedef char VertexType;
typedef int EdgeType;
typedef struct {
    char Vex[MaxVertexNum];
    int Edge[MaxVertexNum][MaxVertexNum];
    int vexnum, arcnum;
}MGraph;
```

### 图的邻接表
```c++
typedef struct ArcNode{ // 边表结点
    int adjvex;  // 该弧指向的顶点的位置
    struct ArcNode *next;  // 指向下一条弧的指针
}ArcNode;
typedef struct VNode{  // 顶点表结点
    char data;  // 
    ArcNode *first;  //
}VNode, AdjList[MaxVertexNum];
typedef struct{
    AdjList vertices; // 邻接表
    int vexnum,arcnum; // 图的顶点数和弧数
} ALGraph;  // 以邻接表存储的图类型

```

### 图的广度优先搜索
```c++
bool visited[MaxVertexNum]; // 访问标记数组

void BFSTraverse(Graph G) {
  for (int i = 0; i < G.vexnum; i++)
    visited[i]=false;  // 访问标记数组初始化
  InitQueue(Q);  // 初始化辅助队列Q
  for (int i = 0; i < G.vexnum; i++){  // 从0号顶点开始遍历
    if(!visted[i])  // 对每个连通分量调用一次BFS
      BFS(G, i); 
  }
}
```